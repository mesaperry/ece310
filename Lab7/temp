 2/1:
#import libraries
import numpy as np
import matplotlib.pyplot as plt

from IPython.display import Audio
from skimage.io import imread
from scipy import signal
from scipy.io import wavfile
from linear_convolution import linear_convolution

%matplotlib inline
 2/2:
#Function to complete for 1.a
def dfl_dft(x):
    N = len(x)
    dft = np.zeros(N, dtype=np.complex64)
    #for loop to iterate over 'k'
    for k in range(N):
        #for loop to iterate over 'n'
        for n in range(N):
            dft[k] += x[n] * np.exp(-1j * 2 * np.pi * k / N * n)
    return dft

#Functions to complete for 1.b
#Construct the matrix W
def dft_matrix(N):
    W = np.zeros((N, N),dtype=np.complex64)
    #fill in W however you see fit!
    for i in range(N):
        for j in range(N):
            k = i * j
            W[i,j] = np.exp(-1j * 2 * np.pi * k / N)
    return W

#Take the DFT of signal x using the matrix W
def vectorized_dft(W, x):
    #this should only take one line...
    #refer to the above math if you are unsure!
    dft = W.dot(x)
    return dft
 2/3:
#Provided code for 1.c
#Generate test signal
N = 500
x = np.random.uniform(size=N)

#Test double for-loop implementation
print('Double For Loop Time:')
%timeit dfl_dft(x)
print('')

#Test vectorized implementation
#don't time W matrix construction since this is precomputation that could be practically stored
W = dft_matrix(N)
print('Vectorized Time')
%timeit vectorized_dft(W,x)
print('')

#Test numpy's fft implementation
print('Numpy Time')
%timeit np.fft.fft(x)
print('')

#Test if results are equivalent
print('Double for-loop and numpy fft are equivalent:',np.allclose(dfl_dft(x),np.fft.fft(x)))
print('Vectorized DFT and numpy fft are equivalent:',np.allclose(vectorized_dft(W,x),np.fft.fft(x)))
 2/4:
#Make longer signal that we will window in order to analyze a smaller portion
x = np.array([np.sin(np.pi/4*n) for n in range(200)])
# Case 1 
N1 = 80 #10 full periods
x1 = x[:N1]
x1_fft = np.fft.rfft(x1)
omega_1 = np.linspace(0,np.pi,len(x1_fft))

# case 2
N2 = 78 # 7 full period and one fractional period
x2 = x[:N2]
x2_fft = np.fft.rfft(x2)
omega_2 = np.linspace(0,np.pi,len(x2_fft))

plt.figure(figsize=(10,5))
plt.subplot(121)
plt.stem(x1)
plt.title('Case 1 Signal')
plt.subplot(122)
plt.stem(x2)
plt.title('Case 2 Signal')

plt.figure(figsize=(10,5))
plt.subplot(121)
plt.stem(omega_1, abs(x1_fft))
plt.title('FFT for Case 1')
plt.xlabel('$\omega$')
plt.subplot(122)
plt.stem(omega_2, abs(x2_fft))
plt.title('FFT for case 2')
plt.xlabel('$\omega$')
 2/5:
N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:


#Code for 2.c:
 2/6:
import scipy

N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:


#Code for 2.c:
 2/7:
N = 256
music_mono_short = music_mono[:N] # if we are only given the first 256 samples
fft_short = np.fft.rfft(music_mono_short)
omega = np.linspace(0,np.pi,len(fft_short)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short))
plt.title('DFT for length-256 audio signal')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
 2/8:
fs, music_stereo = wavfile.read('Hallelujah_16k.wav') # Import the sound file
music_mono = music_stereo[:,0] # To obtain mono sound track
Audio(music_mono, rate = fs)
 2/9:
N = 256
music_mono_short = music_mono[:N] # if we are only given the first 256 samples
fft_short = np.fft.rfft(music_mono_short)
omega = np.linspace(0,np.pi,len(fft_short)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short))
plt.title('DFT for length-256 audio signal')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
2/10:
import scipy

N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:
dft_rect = np.fft.rfft(window_rect, 512)
dft_hamming = np.fft.rfft(window_hamming, 512)
dft_kaiser = np.fft.rfft(window_kaiser, 512)
w = np.linspace(0,np.pi,len(dft_rect))

plt.figure(figsize=(10,5))
plt.plot(w, dft_rect)
plt.title('Rectangle Window Magnitude Spectrum')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for 2.c:
2/11:
import scipy

N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:
dft_rect = np.fft.rfft(window_rect, 512)
dft_hamming = np.fft.rfft(window_hamming, 512)
dft_kaiser = np.fft.rfft(window_kaiser, 512)
w = np.linspace(0,np.pi,len(dft_rect))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(dft_rect), label='Rectangle')
plt.plot(w, sig2db(dft_hamming), label='Hamming')
plt.plot(w, sig2db(dft_kaiser), label='Kaiser')
plt.title('Window Magnitude Spectrum')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for 2.c:
2/12:
import scipy

N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:
dft_rect = np.fft.rfft(window_rect, 512)
dft_hamming = np.fft.rfft(window_hamming, 512)
dft_kaiser = np.fft.rfft(window_kaiser, 512)
w = np.linspace(0,np.pi,len(dft_rect))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(dft_rect), label='Rectangle')
plt.plot(w, sig2db(dft_hamming), label='Hamming')
plt.plot(w, sig2db(dft_kaiser), label='Kaiser')
plt.title('Window Magnitude Spectrum')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')
plt.legend()

#Code for 2.c:
2/13:
import scipy

N2 = 78 # number of points we use to create our window
x2 = x[:N2]
# quick function for converting a magnitude response to dB
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)


#Code for 2.a:
window_rect = np.ones(N2)
window_hamming = scipy.signal.hamming(N2)
window_kaiser = scipy.signal.kaiser(N2, 3)

plt.figure(figsize=(10,5))
plt.subplot(131)
plt.stem(window_rect)
plt.title('Rectangle Window')
plt.subplot(132)
plt.stem(window_hamming)
plt.title('Hamming Window')
plt.subplot(133)
plt.stem(window_kaiser)
plt.title('Kaiser Window')

#Code for 2.b:
dft_rect = np.fft.rfft(window_rect, 512)
dft_hamming = np.fft.rfft(window_hamming, 512)
dft_kaiser = np.fft.rfft(window_kaiser, 512)
w = np.linspace(0,np.pi,len(dft_rect))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(dft_rect), label='Rectangle')
plt.plot(w, sig2db(dft_hamming), label='Hamming')
plt.plot(w, sig2db(dft_kaiser), label='Kaiser')
plt.title('Window Magnitude Spectrum')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')
plt.legend()

#Code for 2.c:
dft_rect_result = np.fft.rfft(window_rect*x2, 512)
dft_hamming_result = np.fft.rfft(window_hamming*x2, 512)
dft_kaiser_result = np.fft.rfft(window_kaiser*x2, 512)
w = np.linspace(0,np.pi,len(dft_rect))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(dft_rect_result), label='Rectangle')
plt.plot(w, sig2db(dft_hamming_result), label='Hamming')
plt.plot(w, sig2db(dft_kaiser_result), label='Kaiser')
plt.title('Window Filter Resulting Magnitude Spectrum')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')
plt.legend()
2/14:
fs, music_stereo = wavfile.read('Hallelujah_16k.wav') # Import the sound file
music_mono = music_stereo[:,0] # To obtain mono sound track
Audio(music_mono, rate = fs)
2/15:
N = 256
music_mono_short = music_mono[:N] # if we are only given the first 256 samples
fft_short = np.fft.rfft(music_mono_short)
omega = np.linspace(0,np.pi,len(fft_short)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short))
plt.title('DFT for length-256 audio signal')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
2/16:
# Code for 3a:

zero_padded_music = np.zeros(2048)
zero_padded_music[:N] = music_mono_short
fft_short_padded = np.fft.rfft(zero_padded_music)
omega = np.linspace(0,np.pi,len(fft_short_padded)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short_padded))
plt.title('DFT for length-256 audio signal padded to length 2048')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
2/17:
# Code for 3a:

zero_padded_music = np.zeroes(2048)
zero_padded_music[:N] = music_mono_short
fft_short_padded = np.fft.rfft(zero_padded_music)
omega = np.linspace(0,np.pi,len(fft_short_padded)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short_padded))
plt.title('DFT for length-256 audio signal padded to length 2048')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
2/18:
# Code for 3a:

zero_padded_music = np.zeros(2048)
zero_padded_music[:N] = music_mono_short
fft_short_padded = np.fft.rfft(zero_padded_music)
omega = np.linspace(0,np.pi,len(fft_short_padded)) 
plt.figure(figsize =(10,6))
plt.plot(omega, abs(fft_short_padded))
plt.title('DFT for length-256 audio signal padded to length 2048')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response')
2/19:
fs_a, vowel_a = wavfile.read('a.wav') 
fs_r, cons_r = wavfile.read('r.wav') 
fs_b, cons_b = wavfile.read('b.wav')
2/20: Audio(vowel_a, rate = fs_a)
2/21: Audio(cons_r, rate = fs_r)
2/22: Audio(cons_b, rate = fs_b)
2/23:
nfft = 512
f_a, t_a, S_a = signal.spectrogram(vowel_a, fs_a, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)
f_r, t_r, S_r = signal.spectrogram(cons_r, fs_r, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)
f_b, t_b, S_b = signal.spectrogram(cons_b, fs_b, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)

plt.figure(figsize=(20,5))
plt.subplot(131)
plt.pcolormesh(t_a, f_a, sig2db(S_a))
plt.title('Spectrogram for "a"')
plt.ylim([0, 3000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
plt.subplot(132)
plt.pcolormesh(t_r, f_r, sig2db(S_r))
plt.title('Spectrogram for "r"')
plt.ylim([0, 4000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
plt.subplot(133)
plt.pcolormesh(t_b, f_b, sig2db(S_b))
plt.title('Spectrogram for "b"')
plt.ylim([0, 3000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
2/24:
#Code for 4.b here:
fs_robot, robot_sound = wavfile.read('robot.wav') 
nfft = 512
f_robot, t_robot, S_robot = signal.spectrogram(robot_sound, fs_robot, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)

plt.figure(figsize=(20,5))
plt.pcolormesh(t_robot, f_robot, sig2db(S_robot))
plt.title('Spectrogram for "robot"')
plt.ylim([0, 3000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
2/25:
#Code for 4.b here:
fs_robot, robot_sound = wavfile.read('robot.wav')
Audio(robot_sound, rate = fs_robot)

nfft = 512
f_robot, t_robot, S_robot = signal.spectrogram(robot_sound, fs_robot, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)

plt.figure(figsize=(20,5))
plt.pcolormesh(t_robot, f_robot, sig2db(S_robot))
plt.title('Spectrogram for "robot"')
plt.ylim([0, 3000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
2/26:
#Code for 4.b here:
fs_robot, robot_sound = wavfile.read('robot.wav')
nfft = 512
f_robot, t_robot, S_robot = signal.spectrogram(robot_sound, fs_robot, nperseg = nfft, noverlap = int(nfft/2), nfft = nfft)

plt.figure(figsize=(20,5))
plt.pcolormesh(t_robot, f_robot, sig2db(S_robot))
plt.title('Spectrogram for "robot"')
plt.ylim([0, 3000])
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.colorbar()
2/27:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(x)
    h_fft = np.fft.rfft(h)
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
2/28:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(x)
    h_fft = np.fft.rfft(h)
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
np.allclose(y_base, y_test)
2/29:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, h.size - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, x.size - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
2/30:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, h.len() - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, x.len() - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
2/31:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
2/32:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
np.allclose(y_base, y_test)
2/33:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    print(np.pad(x, (0, len(h) - 1), 'constant'))
    x_fft = np.fft.rfft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
np.allclose(y_base, y_test)
2/34:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/35:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/36:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y.astype(int)

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/37:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/38:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y.absolute

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/39:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y.absolute()

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/40:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.absolute(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/41:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.absolute(np.fft.ifft(x_fft * h_fft)).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/42:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.absolute(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/43:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    omega_x = np.linspace(0,np.pi,len(x_fft))
    omega_h = np.linspace(0,np.pi,len(h_fft))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/44:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/45:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    print(x_fft)
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/46:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/47:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft)).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/48:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/49:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/50:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.rfft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.rfft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/51:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/52:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'), 512)
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'), 512)
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/53:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/54:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, 0, 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, 0, 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/55:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, 0), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, 0), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/56:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/57:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h)), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x)), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/58:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/59:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(h_fft * x_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/60:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (len(h) - 1, 0), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (len(x) - 1, 0), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/61:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (len(h) - 1, 0), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/62:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/63:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (len(h) - 1, 0), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (len(x) - 1, 0), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/64:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/65:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h)), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/66:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/67:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (1, 2), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (1, 2), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/68:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (2, 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (2, 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/69:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (1,/, 'constant'))
    h_fft = np.fft.fft(np.pad(h, (1, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/70:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (1, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (1, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/71:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/72:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/73:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/74:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.fft.ifft(x_fft * h_fft).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/75:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/76:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft)).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/77:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.real(np.fft.ifft(x_fft * h_fft))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/78:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.rint(np.real(np.fft.ifft(x_fft * h_fft)))
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/79:
#Code for 5.a:

#Fill in this function!
def fast_convolution(x,h):
    x_fft = np.fft.fft(np.pad(x, (0, len(h) - 1), 'constant'))
    h_fft = np.fft.fft(np.pad(h, (0, len(x) - 1), 'constant'))
    y = np.rint(np.real(np.fft.ifft(x_fft * h_fft))).astype(int)
    return y

#Test signals
x1 = [1,3,-2,-1]
x2 = [0,2,4,1]
y_base = signal.convolve(x1, x2)
y_test = fast_convolution(x1, x2)
print(y_base)
print(y_test)
2/80:
#Testing framework for parts 5.b-5.d:
L = 2**6 #Change this for each part!
x = np.random.uniform(size=L)
h = np.random.uniform(size=L)
print('Regular Linear Convolution Results:')
%timeit linear_convolution(x,h)
print('Fast Linear Convolution Results:')
%timeit fast_convolution(x,h)
2/81:
#Testing framework for parts 5.b-5.d:
L = 2**10 #Change this for each part!
x = np.random.uniform(size=L)
h = np.random.uniform(size=L)
print('Regular Linear Convolution Results:')
%timeit linear_convolution(x,h)
print('Fast Linear Convolution Results:')
%timeit fast_convolution(x,h)
2/82:
#Testing framework for parts 5.b-5.d:
L = 2**14 #Change this for each part!
x = np.random.uniform(size=L)
h = np.random.uniform(size=L)
print('Regular Linear Convolution Results:')
%timeit linear_convolution(x,h)
print('Fast Linear Convolution Results:')
%timeit fast_convolution(x,h)
2/83:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:


#Code for part 6.b:


#Code for part 6.c:
2/84:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
for r in range(n_rows):
    fft2[r] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_img = np.real(np.fft.ifft2(fft2))

#Code for part 6.b:


#Code for part 6.c:
2/85:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
for r in range(n_rows):
    fft2[r] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_img = np.real(np.fft.ifft2(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_img,'gray')
plt.title('Phased Image')

#Code for part 6.b:


#Code for part 6.c:
2/86:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
for r in range(n_rows):
    fft2[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_cols = np.real(np.fft.ifft2(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_img,'gray')
plt.title('Column Phased Image')

#Code for part 6.b:
for c in range(n_cols):
    fft2[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_rc = np.real(np.fft.ifft(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_img,'gray')
plt.title('Row and Column Phased Image')

#Code for part 6.c:
2/87:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
for r in range(n_rows):
    fft2[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_cols = np.real(np.fft.ifft2(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_cols,'gray')
plt.title('Column Phased Image')

#Code for part 6.b:
for c in range(n_cols):
    fft2[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_rc = np.real(np.fft.ifft(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_rc,'gray')
plt.title('Row and Column Phased Image')

#Code for part 6.c:
2/88:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
for r in range(n_rows):
    fft2[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_cols = np.real(np.fft.ifft2(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_cols,'gray')
plt.title('Column Phased Image')

#Code for part 6.b:
for c in range(n_cols):
    fft2[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_rc = np.real(np.fft.ifft2(fft2))
plt.figure(figsize = (10,6))
plt.imshow(phased_rc,'gray')
plt.title('Row and Column Phased Image')

#Code for part 6.c:
2/89:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
fft2_rows = np.copy(fft2)
for r in range(n_rows):
    fft2_rows[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_rows = np.real(np.fft.ifft2(fft2_row))
plt.figure(figsize = (10,6))
plt.imshow(phased_rows,'gray')
plt.title('Row Phased Image')

#Code for part 6.b:
fft2_cols = np.copy(fft2)
for c in range(n_cols):
    fft2_cols[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_cols = np.real(np.fft.ifft2(fft2_col))
plt.figure(figsize = (10,6))
plt.imshow(phased_cols,'gray')
plt.title('Column Phased Image')

#Code for part 6.c:
fft2_rc = np.copy(fft2)
for r in range(n_rows):
    fft2_rc[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
for c in range(n_cols):
    fft2_rc[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
fft2_rc = np.real(np.fft.ifft2(fft2_rc))
plt.figure(figsize = (10,6))
plt.imshow(phased_cols,'gray')
plt.title('Row and Column Phased Image')
2/90:
#Load and plot original image
img = imread('test-image.jpg')
n_rows = img.shape[0]
n_cols = img.shape[1]
plt.figure(figsize = (10,6))
plt.imshow(img,'gray')
plt.title('Original Image')

#Compute 2D-DFT
fft2 = np.fft.fft2(img)

#Code for part 6.a:
n_0 = 100
fft2_rows = np.copy(fft2)
for r in range(n_rows):
    fft2_rows[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
phased_rows = np.real(np.fft.ifft2(fft2_rows))
plt.figure(figsize = (10,6))
plt.imshow(phased_rows,'gray')
plt.title('Row Phased Image')

#Code for part 6.b:
fft2_cols = np.copy(fft2)
for c in range(n_cols):
    fft2_cols[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_cols = np.real(np.fft.ifft2(fft2_cols))
plt.figure(figsize = (10,6))
plt.imshow(phased_cols,'gray')
plt.title('Column Phased Image')

#Code for part 6.c:
fft2_rc = np.copy(fft2)
for r in range(n_rows):
    fft2_rc[r,:] *= np.exp(-1j * 2 * np.pi * n_0 / n_rows * r)
for c in range(n_cols):
    fft2_rc[:,c] *= np.exp(-1j * 2 * np.pi * n_0 / n_cols * c)
phased_rc = np.real(np.fft.ifft2(fft2_rc))
plt.figure(figsize = (10,6))
plt.imshow(phased_rc,'gray')
plt.title('Row and Column Phased Image')
11/1:
#Import libraries
import numpy as np
import matplotlib.pyplot as plt

from scipy import signal
from skimage.io import imread
from numpy.random import randn
from IPython.display import Audio
from scipy.io import wavfile

#Utility function for dB scaling of magnitude spectra
def sig2db(mag_spec):
    return 20*np.log10(mag_spec)

%matplotlib inline
11/2:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    lpf_n = np.cos(omega_c * (np.arange(N) - M)) / (np.pi * 1j * (np.arange(N) - M))
    
    #apply window function 
    
    return lpf

#Code for part 1.b:


#Code for part 1.c:


#Code for 1.d:
11/3:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = np.cos(omega_c * (np.arange(N) - M)) / (np.pi * 1j * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:


#Code for part 1.c:


#Code for 1.d:
11/4:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = np.cos(omega_c * (np.arange(N) - M)) / (np.pi * 1j * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

w, h = signal.freqz(np.fft.rfft(plf_11, n=512))
plt.figure(figsize=(10,6))
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/5:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = np.cos(omega_c * (np.arange(N) - M)) / (np.pi * 1j * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

w, h = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.figure(figsize=(10,6))
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/6:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
#     M = (N - 1) / 2
    g_n = np.cos(omega_c * np.arange(N)) / (np.pi * 1j * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

w, h = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.figure(figsize=(10,6))
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/7:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

w, h = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.figure(figsize=(10,6))
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/8:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(10,6))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/9:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(10,6))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(311)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(312)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(313)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/10:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(10,6))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/11:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(10,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/12:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    g_n = omega_c / np.pi * np.sinc(omega_c * np.arange(N))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/13:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/14:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/15:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.fft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/16:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.fft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.fft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.fft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/17:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/18:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

# w, h = signal.freqz(b, a) #w = omega/digital frequencies, h = frequency response
# plt.figure(figsize=(10,6))
# plt.title('Toy Frequency Response')
# plt.plot(w,20*np.log10(np.absolute(h))) #plot magnitude of frequency response with db-scaling on y-axis
# plt.xlabel('$\omega$')
# plt.ylabel('Magnitude Response (dB)')

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/19:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(np.fft.rfft(lpf_11, n=512))
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(h_11))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(np.fft.rfft(lpf_25, n=512))
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(h_25))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(np.fft.rfft(lpf_101, n=512))
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(h_101))) #plot magnitude of frequency response with db-scaling on y-axis
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/20:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/21:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/22:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))
signal.freqz(lpf_11)

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/23:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))
20 * np.log10(np.absolute(signal.freqz(lpf_11)))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/24:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))
20 * np.log10(signal.freqz(lpf_11))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/25:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))
20 * np.log10(np.absolute(signal.freqz(lpf_11)))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, 20 * np.log10(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/26:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))
20 * np.log10(np.absolute(signal.freqz(lpf_11)))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/27:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_11))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_25))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_101))))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/28:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))

plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_11)[1])))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_25)[1])))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w, sig2db(np.absolute(signal.freqz(lpf_101)[1])))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/29:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
w = np.arange(512) * np.pi / 512
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/30:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/31:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N)))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/32:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('Frequency Response of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Frequency Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Frequency Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/33:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('Magnitude Response of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Magnitude Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Magnitude Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/34:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)

plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11)
plt.subplot(131)
plt.title('|H(z)| of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25)
plt.subplot(132)
plt.title('Magnitude Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101)
plt.subplot(133)
plt.title('Magnitude Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/35:
"""
signal.remez(numtaps,bands,desired,fs=2)
Inputs:
numtaps - Filter length.
bands - List of band edges in normalized frequency [0,1]
        where 1 correponds to pi.
desired - List of desired gains for each frequency bands.
          Must be half the length of the bands list.
fs=2 - This argument guarantees the input frequencies are on the normalized
       [0,1] frequency axis.
Output:
out - Array of computed FIR filter coefficients.
"""

N = 50
a = [1,0]
#Low-pass Filter
#0-0.5 is passband, 0.7-1 is the stopband, transition band is then 0.5-0.7
lpf_bands = [0,0.5,0.7,1]
lpf_desired = [1,0] #gain of one for passband, gain of zero for stopband
lpf = signal.remez(N,lpf_bands,lpf_desired,fs=2)
w,H_lpf = signal.freqz(lpf,a)
#Band-pass Filter
#0-0.2 is first stopband, 0.3-0.6 is passband, 0.7-1 is second stopband
bpf_bands = [0,0.2,0.3,0.6,0.7,1]
bpf_desired = [0,1,0]
bpf = signal.remez(N,bpf_bands,bpf_desired,fs=2)
w,H_bpf = signal.freqz(bpf,a)

#Compare magnitude responses
plt.figure(figsize=(15,6))
plt.subplot(121)
plt.title('Low-pass Filter')
plt.plot(w,sig2db(abs(H_lpf)))
plt.subplot(122)
plt.title('Band-pass Filter')
plt.plot(w,sig2db(abs(H_bpf)))
11/36:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = omega_c / np.pi * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('|H(z)| of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('Magnitude Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('Magnitude Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/37:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('|H(z)| of LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('Magnitude Response of LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('Magnitude Response of LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/38:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/39:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/40:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(np.absolute(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(np.absolute(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(np.absolute(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/41:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/42:
#Code for 2.a:
N = 50
a = [1,0]
#Low-pass Filter
#0-0.5 is passband, 0.7-1 is the stopband, transition band is then 0.5-0.7
lpf_bands = [0,0.5,0.7,1]
lpf_desired = [1,0] #gain of one for passband, gain of zero for stopband
lpf = signal.remez(N,lpf_bands,lpf_desired,fs=2)
w,H_lpf = signal.freqz(lpf,a)
#Band-pass Filter
#0-0.2 is first stopband, 0.3-0.6 is passband, 0.7-1 is second stopband
bpf_bands = [0,0.2,0.3,0.6,0.7,1]
bpf_desired = [0,1,0]
bpf = signal.remez(N,bpf_bands,bpf_desired,fs=2)
w,H_bpf = signal.freqz(bpf,a)

#Compare magnitude responses
plt.figure(figsize=(15,6))
plt.subplot(121)
plt.title('Low-pass Filter')
plt.plot(w,sig2db(abs(H_lpf)))
plt.subplot(122)
plt.title('Band-pass Filter')
plt.plot(w,sig2db(abs(H_bpf)))

hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(131)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(131)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
11/43:
#Code for 2.a:
N = 50
a = [1,0]
#Low-pass Filter
#0-0.5 is passband, 0.7-1 is the stopband, transition band is then 0.5-0.7
lpf_bands = [0,0.5,0.7,1]
lpf_desired = [1,0] #gain of one for passband, gain of zero for stopband
lpf = signal.remez(N,lpf_bands,lpf_desired,fs=2)
w,H_lpf = signal.freqz(lpf,a)
#Band-pass Filter
#0-0.2 is first stopband, 0.3-0.6 is passband, 0.7-1 is second stopband
bpf_bands = [0,0.2,0.3,0.6,0.7,1]
bpf_desired = [0,1,0]
bpf = signal.remez(N,bpf_bands,bpf_desired,fs=2)
w,H_bpf = signal.freqz(bpf,a)

#Compare magnitude responses
plt.figure(figsize=(15,6))
plt.subplot(121)
plt.title('Low-pass Filter')
plt.plot(w,sig2db(abs(H_lpf)))
plt.subplot(122)
plt.title('Band-pass Filter')
plt.plot(w,sig2db(abs(H_bpf)))

hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
11/44:
#Code for 2.a:

hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
11/45:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
11/46:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.6,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
11/47:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.65,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
11/48:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.7,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
11/49:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
11/50:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/51:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(1001,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/52:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(505,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/53:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/54:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(201,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/55:
#Code for 2.a:
hpf_bands = [0,0.5,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
hpf_25 = signal.remez(25,hpf_bands,hpf_desired,fs=2)
hpf_101 = signal.remez(101,hpf_bands,hpf_desired,fs=2)

plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.subplot(131)
plt.title('HPF N = 11')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_25,a)
plt.subplot(132)
plt.title('HPF N = 25')
plt.plot(w,sig2db(abs(H_hpf)))
w,H_hpf = signal.freqz(hpf_101,a)
plt.subplot(133)
plt.title('HPF N = 101')
plt.plot(w,sig2db(abs(H_hpf)))

#Code for 2.b:
hpf_bands = [0,0.69,0.7,1]
hpf_desired = [0,1]
hpf_11 = signal.remez(11,hpf_bands,hpf_desired,fs=2)
plt.figure(figsize=(15,6))
w,H_hpf = signal.freqz(hpf_11,a)
plt.title('HPF N = 11 and reduced transition bandwidth')
plt.plot(w,sig2db(abs(H_hpf)))
11/56:
fs, audio = wavfile.read('sound1.wav')
Audio(data = audio, rate = fs)
11/57:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(dft_audio))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:


#Code for part 3.c:
11/58:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:


#Code for part 3.c:
11/59:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('HPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
11/60:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('HPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
11/61:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('HPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
11/62:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('LPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
11/63:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('LPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:

audio_filtered = signal.convolve(audio, filter_remez)
11/64:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.5,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('LPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
audio_filtered = signal.convolve(audio, filter_remez)
plt.figure(figsize=(15,6))
w,H = signal.freqz(audio_filtered)
plt.title('Filtered Audio FFT Magnitude')
plt.plot(w,sig2db(abs(H)))
11/65:
#Verify your filtered audio here!
Audio(data = audio_filtered, rate = fs)
11/66:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.45,0.65,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('LPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
audio_filtered = signal.convolve(audio, filter_remez)
plt.figure(figsize=(15,6))
w,H = signal.freqz(audio_filtered)
plt.title('Filtered Audio FFT Magnitude')
plt.plot(w,sig2db(abs(H)))
11/67:
#Verify your filtered audio here!
Audio(data = audio_filtered, rate = fs)
11/68:
#Code for part 3.a:
dft_audio = np.fft.rfft(audio)
w = np.linspace(0,np.pi,len(dft_audio))

plt.figure(figsize=(10,5))
plt.plot(w, sig2db(abs(dft_audio)))
plt.title('Audio Signal FFT Magnitude')
plt.xlabel(r'$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 3.b:
filter_bands = [0,0.4,0.6,1]
filter_desired = [1,0]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.title('LPF')
plt.plot(w,sig2db(abs(H)))

#Code for part 3.c:
audio_filtered = signal.convolve(audio, filter_remez)
plt.figure(figsize=(15,6))
w,H = signal.freqz(audio_filtered)
plt.title('Filtered Audio FFT Magnitude')
plt.plot(w,sig2db(abs(H)))
11/69:
#Verify your filtered audio here!
Audio(data = audio_filtered, rate = fs)
11/70:
noisy = imread('noisy-photo.jpg')
plt.figure(figsize=(10,6))
plt.imshow(noisy,'gray')
plt.title('Noisy Image')
11/71:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(121)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(122)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))

#Code for part 4.b:


#Code for part 4.c:
11/72:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(221)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,sig2db(np.angle(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,sig2db(np.angle(H_iir)))

#Code for part 4.b:


#Code for part 4.c:
11/73:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(221)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(222)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,snp.angle(H_iir))

#Code for part 4.b:


#Code for part 4.c:
11/74:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(221)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(222)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:


#Code for part 4.c:
11/75:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:


#Code for part 4.c:
11/76:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.zeros(image.shape)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],h,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],h,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/77:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.zeros(shape)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],h,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],h,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/78:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.zeros(shape)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/79:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.zeros(shape)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],H,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],H,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/80:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/81:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],H,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],H,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/82:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
11/83:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.lfilter(image_row_col[i,:],a,filter_remez)
for i in range(n_cols):
    image_row_col[:,i] = signal.lfilter(image_row_col[:,i],a,filter_remez,)
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('IIR Filtered Image')
11/84:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.lfilter(image_row_col[i,:],a,filter_remez)
for i in range(n_cols):
    image_row_col[:,i] = signal.lfilter(image_row_col[:,i],a,filter_remez)
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('IIR Filtered Image')
11/85:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.lfilter(iir_num,iir_den,image_row_col[i,:])
for i in range(n_cols):
    image_row_col[:,i] = signal.lfilter(iir_num,iir_denimage_row_col[:,i])
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('IIR Filtered Image')
11/86:
#Provided code:
shape = noisy.shape
n_rows,n_cols = shape[0],shape[1]

iir_num,iir_den = signal.iirdesign(ws=[0.2,0.5],wp=[0.15,0.55],gpass=1,gstop=25)
w,H_iir = signal.freqz(iir_num,iir_den)

#Code for part 4.a:
filter_bands = [0,0.1,0.2,0.5,0.6,1]
filter_desired = [1,0,1]
filter_remez = signal.remez(25,filter_bands,filter_desired,fs=2)
plt.figure(figsize=(15,6))
w,H = signal.freqz(filter_remez)
plt.subplot(221)
plt.title('FIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H)))
plt.subplot(222)
plt.title('IIR Filter FFT Magnitude Response')
plt.plot(w,sig2db(abs(H_iir)))
plt.subplot(223)
plt.title('FIR Filter FFT Phase Response')
plt.plot(w,np.angle(H))
plt.subplot(224)
plt.title('IIR Filter FFT Phase Response')
plt.plot(w,np.angle(H_iir))

#Code for part 4.b:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.convolve(image_row_col[i,:],filter_remez,'same')
for i in range(n_cols):
    image_row_col[:,i] = signal.convolve(image_row_col[:,i],filter_remez,'same')
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('FIR Filtered Image')

#Code for part 4.c:
image_row_col = np.copy(noisy)
for i in range(n_rows):
    image_row_col[i,:] = signal.lfilter(iir_num,iir_den,image_row_col[i,:])
for i in range(n_cols):
    image_row_col[:,i] = signal.lfilter(iir_num,iir_den,image_row_col[:,i])
plt.figure(figsize=(15,6))
plt.imshow(image_row_col, 'gray')
plt.title('IIR Filtered Image')
11/87:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err_, w_ = lms(x,y,h,10**-4,np.zero(h.size)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/88:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err_, w_ = lms(x,y,h,10**-4,np.zero(h.size))

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/89:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err_, w_ = lms(x,y,h,10**-4,np.zeros(h.size))

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/90:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(w_err.size, w_err)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/91:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(w_err.size, w_err)
print(w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/92:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print(w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/93:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate: " + w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/94:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate: ", w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/95:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:)
print(w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/96:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/97:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/98:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:


#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/99:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/100:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/101:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(211)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(212)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/102:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,15))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/103:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/104:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/105:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(221)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(222)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(223)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(224)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/106:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
11/107:
#Provided functions
def generate_xy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x)
    return x,y

def generate_xy_noisy(h,N):
    x = np.random.randint(low=-25,high=26,size = N)
    y = signal.convolve(h,x).astype(np.float64)
    y += randn(len(y))*3 #Gaussian noise with standard deviation 3
    return x,y

#Fill in missing line for Part 5.a:
"""
lms(x,y,h,alpha,w_init):
Inputs:
x - input signal
y - output signal
h - your friend's filter (to check how well we learn it)
alpha - learning rate
w_init - initial filter coefficients

Outputs:
w_err - L2 errors (Euclidean distance) of LMS filter against your friend's filter
w - final estimate of your friend's filter
"""
def lms(x,y,h,alpha,w_init):
    N,L = len(x),len(h)
    w = w_init #adaptive filter
    w_err = np.zeros(N) #array to track filter coefficient errors
    X = np.zeros(L) #memory signal
    for n in range(N):
        X[0] = x[n] #update most recent (current) value
        d_n = y[n] #step to predict
        y_predict = np.dot(w,X) #predict y by w^Tx
        w_err[n] = np.linalg.norm(h - w) #error in filter coefficients
        e_n = d_n - y_predict #prediction error
        w = w + alpha * e_n * X #filter update by gradient descent
        X = np.roll(X,1) #circularly shift right by one
    return w_err,w

h = np.array([1,2,3,4,5])
N = 500
x,y = generate_xy(h,N)

#Code for part 5.a:
w_err, w = lms(x,y,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error')
plt.plot(range(w_err.size), w_err)
print("5.a estimate:")
print(w)

#Code for part 5.b:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-2,np.zeros(h.size))
plt.subplot(121)
plt.title('Filter Error with alpha=10**-2')
plt.plot(range(w_err.size), w_err)
w_err, w = lms(x,y,h,10**-6,np.zeros(h.size))
plt.subplot(122)
plt.title('Filter Error with alpha=10**-6')
plt.plot(range(w_err.size), w_err)


#Code for part 5.c:
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.ones(h.size))
plt.subplot(121)
plt.title('Filter Error for initial ones filter')
plt.plot(range(w_err.size), w_err)
plt.figure(figsize=(15,6))
w_err, w = lms(x,y,h,10**-4,np.random.randn(h.size))
plt.subplot(122)
plt.title('Filter Error for initial random filter')
plt.plot(range(w_err.size), w_err)

#Code for part 5.d:
x_noisy,y_noisy = generate_xy_noisy(h,N)
w_err, w = lms(x_noisy,y_noisy,h,10**-4,np.zeros(h.size))
plt.figure(figsize=(15,6))
plt.title('Filter Error for noisy input and output')
plt.plot(range(w_err.size), w_err)
print("5.d estimate:")
print(w)
11/108:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(311)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(312)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(313)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/109:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/110:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 18, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/111:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    print(np.arange(N) - M)
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/112:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    print(lpf_n)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(a(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/113:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M))
    
    #apply window function 
    lpf_n = g_n * window(N)
    print(omega_c * (np.arange(N) - M))
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(a(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/114:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    print(omega_c * (np.arange(N) - M))
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(a(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/115:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(a(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/116:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:


#Code for 1.d:
11/117:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
11/118:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
11/119:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = np.pi * 2
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/120:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = np.pi
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/121:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = np.pi / 2
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/122:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = -np.pi / 2
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/123:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = -np.pi / 2
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/124:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = -np.pi
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/125:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = 1
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/126:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
shift = 2
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) * shift / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/127:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/128:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/129:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j / 2 * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/130:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/131:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/132:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-3j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/133:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-5j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/134:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-12j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/135:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-25j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/136:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-50j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/137:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-25j * np.pi * np.arange(25) / 25)
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/138:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-25j * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/139:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/140:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-2j * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/141:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * 3/2 * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/142:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/143:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * 2 * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
11/144:
#Fill in this function for part 1.a:
def windowed_lpf(omega_c,N,window=np.ones):
    #create ideal impulse response in time domain before windowing
    M = (N - 1) / 2
    g_n = (omega_c / np.pi) * np.sinc(omega_c * (np.arange(N) - M) / np.pi)
    
    #apply window function 
    lpf_n = g_n * window(N)
    return lpf_n

#Code for part 1.b:
lpf_11 = windowed_lpf(np.pi / 3, 11)
lpf_25 = windowed_lpf(np.pi / 3, 25)
lpf_101 = windowed_lpf(np.pi / 3, 101)
a = [1,0]
plt.figure(figsize=(20,10))

w_11, h_11 = signal.freqz(lpf_11, a)
plt.subplot(131)
plt.title('LPF where N = 11')
plt.plot(w_11, sig2db(abs(h_11)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_25, h_25 = signal.freqz(lpf_25, a)
plt.subplot(132)
plt.title('LPF where N = 25')
plt.plot(w_25, sig2db(abs(h_25)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_101, h_101 = signal.freqz(lpf_101, a)
plt.subplot(133)
plt.title('LPF where N = 101')
plt.plot(w_101, sig2db(abs(h_101)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

#Code for part 1.c:
lpf_hamming = windowed_lpf(np.pi / 3, 25, np.hamming)
lpf_hanning = windowed_lpf(np.pi / 3, 25, np.hanning)
lpf_bartlett = windowed_lpf(np.pi / 3, 25, np.bartlett)
a = [1,0]
plt.figure(figsize=(20,10))

w_hamming, h_hamming = signal.freqz(lpf_hamming, a)
plt.subplot(131)
plt.title('LPF w/ Hamming filter')
plt.plot(w_hamming, sig2db(abs(h_hamming)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_hanning, h_hanning = signal.freqz(lpf_hanning, a)
plt.subplot(132)
plt.title('LPF w/ Hanning Filter')
plt.plot(w_hanning, sig2db(abs(h_hanning)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')

w_bartlett, h_bartlett = signal.freqz(lpf_bartlett, a)
plt.subplot(133)
plt.title('LPF w/ Bartlett Filter')
plt.plot(w_bartlett, sig2db(abs(h_bartlett)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')


#Code for 1.d:
hpf = windowed_lpf(np.pi / 2, 25, np.hamming) * np.exp(-1j * np.pi * np.arange(25))
plt.figure(figsize=(20,10))
w_hpf, h_hpf = signal.freqz(hpf, a)
plt.title('HPF')
plt.plot(w_hpf, sig2db(abs(h_hpf)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude Response (dB)')
   1:
#import libraries
import numpy as np
import matplotlib.pyplot as plt

from scipy import signal
from skimage.io import imread
from skimage.io import imsave

#Provided function with triangle magnitude spectrum
def toy_signal(w_c):
    N = 1000
    gain = 2*np.pi/w_c
    return gain * np.array([(np.sin(w_c/2*(n+1))/(np.pi*(n+1)))**2 if n+1 != 0 else (w_c/(2*np.pi))**2 for n in range(-N,N+1)])

%matplotlib inline
   2:
#import libraries
import numpy as np
import matplotlib.pyplot as plt

from scipy import signal
from skimage.io import imread
from skimage.io import imsave

#Provided function with triangle magnitude spectrum
def toy_signal(w_c):
    N = 1000
    gain = 2*np.pi/w_c
    return gain * np.array([(np.sin(w_c/2*(n+1))/(np.pi*(n+1)))**2 if n+1 != 0 else (w_c/(2*np.pi))**2 for n in range(-N,N+1)])

%matplotlib inline
   3:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros(x.size * (U - 1) + 1)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:


#Code for part 1.c:
   4:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros(x.size * (U - 1) + 1)
    print(upsampled.size)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:


#Code for part 1.c:
   5:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1)
    print(upsampled.size)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:


#Code for part 1.c:
   6:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:


#Code for part 1.c:
   7:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:


#Code for part 1.c:
   8:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print(test_signal)
print(upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)


#Code for part 1.c:
   9:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original: ", test_signal)
print("upsampled: ", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)


#Code for part 1.c:
  10:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)


#Code for part 1.c:
  11:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w, X = signal.freqz(toy_og)
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, sig2db(abs(X)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  12:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w, X = signal.freqz(toy_og)
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  13:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))
w = np.linspace(0,np.pi,len(dft_audio))

w_og, X_og = signal.freqz(toy_og)
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  14:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))
w = np.linspace(0,np.pi,len(toy_og))

w_og, X_og = signal.freqz(toy_og)
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  15:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = signal.freqz(toy_og)
w = np.linspace(0,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  16:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = signal.freqz(toy_og)
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  17:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = signal.freqz(toy_og)
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(np.fft.fftshift(X_og)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  18:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = signal.freqz(toy_og)
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(np.fft.fftshift(X_og)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  19:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = signal.freqz(toy_og, [1,0])
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(np.fft.fftshift(X_og)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  20:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

w_og, X_og = np.fft.rfft(toy_og)
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(np.fft.fftshift(X_og)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  21:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

X_og = np.fft.rfft(toy_og)
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(np.fft.fftshift(X_og)))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  22:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

X_og = np.fft.fftshift(np.fft.rfft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  23:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
toy_og = toy_signal(np.pi / 2)
toy_us = upsample(3, toy_og)

plt.figure(figsize=(20,10))

X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  24:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude (dB)')

#Code for part 1.c:
  25:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    
    return lpf

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
  26:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(2,filter_bands,filter_desired,fs=2)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  27:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(2,filter_bands,filter_desired,fs=50)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  28:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  29:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=3)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  30:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=4)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  31:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C-0.05,C+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  32:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C/np.pi-0.05,C/np.pi+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    print(filter_remez.size)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lp_3 = lowpass(np.pi / 3)
  33:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C/np.pi-0.05,C/np.pi+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(121)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(122)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lpf_3 = lowpass(np.pi / 3)
toy_f = signal.convolve(toy_us, lpf_3)
X_f = np.fft.fftshift(np.fft.fft(toy_f))
w = np.linspace(-np.pi,np.pi,len(X_f))
plt.subplot(122)
plt.title('Filtered Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_f))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  34:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros((x.size - 1) * U + 1, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C/np.pi-0.05,C/np.pi+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(132)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lpf_3 = lowpass(np.pi / 3)
toy_f = signal.convolve(toy_us, lpf_3)
X_f = np.fft.fftshift(np.fft.fft(toy_f))
w = np.linspace(-np.pi,np.pi,len(X_f))
plt.subplot(133)
plt.title('Filtered Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_f))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  35:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(test_signal, 2))

#Code for part 2.b:


#Code for part 2.c:


#Code for part 2.d:
  36:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:


#Code for part 2.c:


#Code for part 2.d:
  37:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds = upsample(3, toy_og)
X_ds = np.fft.fftshift(np.fft.fft(toy_ds))
w = np.linspace(-np.pi,np.pi,len(X_ds))
plt.subplot(132)
plt.title('Downsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:


#Code for part 2.d:
  38:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds = downsample(3, toy_og)
X_ds = np.fft.fftshift(np.fft.fft(toy_ds))
w = np.linspace(-np.pi,np.pi,len(X_ds))
plt.subplot(132)
plt.title('Downsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:


#Code for part 2.d:
  39:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds = downsample(2, toy_og)
X_ds = np.fft.fftshift(np.fft.fft(toy_ds))
w = np.linspace(-np.pi,np.pi,len(X_ds))
plt.subplot(132)
plt.title('Downsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:


#Code for part 2.d:
  40:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(2, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
  41:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
  42:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
plt.figure(figsize=(20,10))

toy_ud = downsample(5, upsample(3, toy_og))
X_ud = np.fft.fftshift(np.fft.fft(toy_ud))
w = np.linspace(-np.pi,np.pi,len(X_ud))
plt.subplot(121)
plt.title('Upsample Then Downsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ud))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  43:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
plt.figure(figsize=(20,10))

toy_ud = downsample(5, signal.convolve(upsample(3, toy_og), lpf(np.pi / 5)))
X_ud = np.fft.fftshift(np.fft.fft(toy_ud))
w = np.linspace(-np.pi,np.pi,len(X_ud))
plt.subplot(121)
plt.title('Upsample Then Downsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ud))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  44:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
plt.figure(figsize=(20,10))

toy_ud = downsample(5, signal.convolve(upsample(3, toy_og), lowpass(np.pi / 5)))
X_ud = np.fft.fftshift(np.fft.fft(toy_ud))
w = np.linspace(-np.pi,np.pi,len(X_ud))
plt.subplot(121)
plt.title('Upsample Then Downsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ud))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  45:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
plt.figure(figsize=(20,10))

toy_ud = downsample(5, signal.convolve(upsample(3, toy_og), lowpass(np.pi / 5)))
X_ud = np.fft.fftshift(np.fft.fft(toy_ud))
w = np.linspace(-np.pi,np.pi,len(X_ud))
plt.subplot(121)
plt.title('Upsample Then Downsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ud))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_du = signal.convolve(upsample(3, downsample(5, signal.convolve(toy_og, lowpass(np.pi / 5)))), lowpass(np.pi / 3))
X_du = np.fft.fftshift(np.fft.fft(toy_du))
w = np.linspace(-np.pi,np.pi,len(X_du))
plt.subplot(122)
plt.title('Downsample The Upsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_du))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  46:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i/U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
image.show(small_img)

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  47:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i/U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
Image.show(small_img)

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  48:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i/U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img)

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  49:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i/U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  50:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i/U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  51:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[int(i/U),:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  52:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros(x.size * U, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C/np.pi-0.05,C/np.pi+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(132)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lpf_3 = lowpass(np.pi / 3)
toy_f = signal.convolve(toy_us, lpf_3)
X_f = np.fft.fftshift(np.fft.fft(toy_f))
w = np.linspace(-np.pi,np.pi,len(X_f))
plt.subplot(133)
plt.title('Filtered Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_f))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  53:
#Fill in this function for part 2.a:
def downsample(D,x):
    downsampled = x[::D]
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])
print("test signal:", test_signal)
print("decimated test signal:", downsample(2, test_signal))

#Code for part 2.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_ds2 = downsample(2, toy_og)
X_ds2 = np.fft.fftshift(np.fft.fft(toy_ds2))
w = np.linspace(-np.pi,np.pi,len(X_ds2))
plt.subplot(132)
plt.title('Downsampled By 2 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds2))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 2.c:

toy_ds3 = downsample(3, toy_og)
X_ds3 = np.fft.fftshift(np.fft.fft(toy_ds3))
w = np.linspace(-np.pi,np.pi,len(X_ds3))
plt.subplot(133)
plt.title('Downsampled By 3 Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ds3))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')


#Code for part 2.d:
plt.figure(figsize=(20,10))

toy_ud = downsample(5, signal.convolve(upsample(3, toy_og), lowpass(np.pi / 5)))
X_ud = np.fft.fftshift(np.fft.fft(toy_ud))
w = np.linspace(-np.pi,np.pi,len(X_ud))
plt.subplot(121)
plt.title('Upsample Then Downsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_ud))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_du = signal.convolve(upsample(3, downsample(5, signal.convolve(toy_og, lowpass(np.pi / 5)))), lowpass(np.pi / 3))
X_du = np.fft.fftshift(np.fft.fft(toy_du))
w = np.linspace(-np.pi,np.pi,len(X_du))
plt.subplot(122)
plt.title('Downsample The Upsample Toy Signal FFT Magnitude')
plt.plot(w, abs(X_du))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  54:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[int(i/U),:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  55:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[floor(i/U),:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  56:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows):
        up_img[i,:] = upsample(U, img[i//U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  57:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows*U):
        up_img[i,:] = upsample(U, img[i//U,:])
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  58:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows*U):
        up_img[i,:] = upsample(U, img[i//U,:])
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.imshow(small_img, 'gray')
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  59:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    for i in range(n_rows*U):
        up_img[i,:] = upsample(U, img[i//U,:])
    return x

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(131)
plt.imshow(small_img, 'gray')
plt.subplot(132)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  60:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = img.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,:] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(131)
plt.imshow(small_img, 'gray')
plt.subplot(132)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(132)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  61:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,:] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(131)
plt.imshow(small_img, 'gray')
plt.subplot(132)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(132)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  62:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,:] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(131)
plt.imshow(small_img, 'gray')
plt.subplot(132)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(133)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  63:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(131)
plt.imshow(small_img, 'gray')
plt.subplot(132)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(133)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  64:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out = signal.convolve(x_out[i,:], linear_filter)
    for j in range(n_cols):
        x_out = signal.convolve(x_out[:,j], linear_filter)
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  65:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    print(x_out.shape)
    for i in range(n_rows):
        x_out = signal.convolve(x_out[i,:], linear_filter)
    for j in range(n_cols):
        x_out = signal.convolve(x_out[:,j], linear_filter)
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  66:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:]
        x_out = signal.convolve(x_out[i,:], linear_filter)
    for j in range(n_cols):
        x_out = signal.convolve(x_out[:,j], linear_filter)
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  67:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        print(x_out.shape)
        x_out[i,:]
        x_out = signal.convolve(x_out[i,:], linear_filter)
    for j in range(n_cols):
        x_out = signal.convolve(x_out[:,j], linear_filter)
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  68:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  69:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3


#Code for part 3.b:


#Code for part 3.c:


#Code for part 3.d:
  70:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3
print("test_signal:", test_signal)
print("nn test_signal:", nn(3, test_signal))
print("linear test_signal:" linear(3, test_signal))

#Code for part 3.b:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.c:
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.d:
  71:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([1.,0,0,10,0,0,4,0,0]) #U = 3
print("test_signal:", test_signal)
print("nn test_signal:", nn(3, test_signal))
print("linear test_signal:", linear(3, test_signal))

#Code for part 3.b:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.c:
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.d:
  72:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    print(linear_filter)
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([[1.,0,0,10,0,0,4,0,0]]) #U = 3
print("test_signal:", test_signal)
print("nn test_signal:", nn(3, test_signal))
print("linear test_signal:", linear(3, test_signal))

#Code for part 3.b:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.c:
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.d:
  73:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([[1.,0,0,10,0,0,4,0,0]]) #U = 3
print("test_signal:", test_signal)
print("nn test_signal:", nn(3, test_signal))
print("linear test_signal:", linear(3, test_signal))

#Code for part 3.b:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.c:
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')


#Code for part 3.d:
  74:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([[1.,0,0,10,0,0,4,0,0]]) #U = 3
print("test_signal:", test_signal)

#Code for part 3.b:
print("nn test_signal:", nn(3, test_signal))

#Code for part 3.c:
print("linear test_signal:", linear(3, test_signal))

#Code for part 3.d:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')
  75:
#Fill in this function for part 3.a:
def upsample_image(U,img):
    n_rows,n_cols = img.shape
    up_img = np.zeros((n_rows*U,n_cols*U))
    up_img[::U,::U] = img
    return up_img

#Fill in this function for part 3.b
#Assume x has already been upsampled
def nn(U,x):
    n_rows,n_cols = x.shape
    x_out = np.copy(x)
    for i in range(n_rows):
        for j in range(n_cols):
            x_out[i,j] = x[(i//U) * U, (j//U) * U]
    return x_out

#Fill in this function for part 3.c:
#Assume x has already been upsampled
def linear(U,x):
    linear_filter = np.zeros(2 * U - 1)
    for i in range(U):
        linear_filter[U - 1 + i] = 1 - i / U
        linear_filter[U - 1 - i] = 1 - i / U
    x_out = np.copy(x)
    n_rows,n_cols = x.shape
    for i in range(n_rows):
        x_out[i,:] = signal.convolve(x_out[i,:], linear_filter)[U-1:-(U-1)]
    for j in range(n_cols):
        x_out[:,j] = signal.convolve(x_out[:,j], linear_filter)[U-1:-(U-1)]
    return x_out

#Code for part 3.a:
small_img = imread('small-img.jpg')
plt.figure(figsize=(20,5))
plt.subplot(141)
plt.imshow(small_img, 'gray')
plt.subplot(142)
plt.imshow(upsample_image(8, small_img), 'gray')

#Test signal for parts 3.b and 3.c:
test_signal = np.array([[1.,0,0,10,0,0,4,0,0]]) #U = 3
print("test_signal:", test_signal)

#Code for part 3.b:
print("nn test_signal:", nn(3, test_signal))

#Code for part 3.c:
print("linear test_signal:", linear(3, test_signal))

#Code for part 3.d:
plt.subplot(143)
plt.imshow(nn(8, upsample_image(8, small_img)), 'gray')
plt.subplot(144)
plt.imshow(linear(8, upsample_image(8, small_img)), 'gray')
  76:
def load_temp_data(season_string):
    file_name = season_string + '.npy'
    data = np.load(file_name)
    lows = np.zeros(data.shape)
    lows[:,0] = data[:,0]
    lows[:,1] = np.ones(data.shape[0]) #augment column of ones
    highs = data[:,1]
    return lows,highs

winter_lows,winter_highs = load_temp_data('winter')
spring_lows,spring_highs = load_temp_data('spring')
summer_lows,summer_highs = load_temp_data('summer')
fall_lows,fall_highs = load_temp_data('fall')
  77:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()

    return mse

#Code for 4.b:


#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  78:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix

    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / N
    return mse

#Code for 4.b:


#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  79:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    w = np.matmul(np.linalg.inv(np.matmul(low.transpose(), low))), np.matmul(low.transpose(), high))
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / N
    return mse

#Code for 4.b:
visualize_solution(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs), "Winter")
print(mse(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs)))

#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  80:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    w = np.matmul(np.linalg.inv(np.matmul(low.transpose(), low)), np.matmul(low.transpose(), high))
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / N
    return mse

#Code for 4.b:
visualize_solution(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs), "Winter")
print(mse(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs)))

#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  81:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    w = np.matmul(np.linalg.inv(np.matmul(low.transpose(), low)), np.matmul(low.transpose(), high))
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / high.size()
    return mse

#Code for 4.b:
visualize_solution(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs), "Winter")
print(mse(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs)))

#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  82:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    w = np.matmul(np.linalg.inv(np.matmul(low.transpose(), low)), np.matmul(low.transpose(), high))
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / high.size
    return mse

#Code for 4.b:
visualize_solution(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs), "Winter")
print(mse(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs)))

#Code for 4.c:


#Code for 4.d:


#Code for 4.e:
  83:
#Provided function
"""
Inputs:
low_data - One-augmented low temperature data for the given season.
high_data - High temperature data for the given season.
w - Solution vector for the given season (Should be length two!).
title - String for the title of your plot.

Example usage: visualize_solution(winter_low,winter_highs,winter_w,'Winter Solution and Data')
"""
def visualize_solution(low_data,high_data,w,title):
    if len(w) != 2:
        print('Incorrect solution dimension!')
        return
    min_low = np.min(low_data[:,0])
    max_low = np.max(low_data[:,0])
    x = np.linspace(min_low,max_low,1000)
    y = w[0]*x + w[1]
    plt.figure(figsize=(10,6))
    plt.title(title)
    plt.scatter(low_data[:,0],high_data,label='Data')
    plt.plot(x,y,'r--',label='Linear Regression')
    plt.xlabel('Low Temperatures')
    plt.ylabel('High Temperatures')
    plt.legend()

#Fill in these functions for part 4.a:    
def linear_regression(low,high):
    #Hint: use np.linalg.inv() to invert a matrix
    w = np.matmul(np.linalg.inv(np.matmul(low.transpose(), low)), np.matmul(low.transpose(), high))
    return w

def mse(low,high,w):
    #Hint: use np.linalg.norm()
    mse = np.linalg.norm(np.matmul(low, w) - high) ** 2 / high.size
    return mse

#Code for 4.b:
visualize_solution(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs), "Winter")
print(mse(winter_lows, winter_highs, linear_regression(winter_lows, winter_highs)))

#Code for 4.c:
visualize_solution(spring_lows, spring_highs, linear_regression(spring_lows, spring_highs), "Spring")
print(mse(spring_lows, spring_highs, linear_regression(spring_lows, spring_highs)))

#Code for 4.d:
visualize_solution(summer_lows, summer_highs, linear_regression(summer_lows, summer_highs), "Summer")
print(mse(summer_lows, summer_highs, linear_regression(summer_lows, summer_highs)))

#Code for 4.e:
visualize_solution(fall_lows, fall_highs, linear_regression(fall_lows, fall_highs), "Summer")
print(mse(fall_lows, fall_highs, linear_regression(fall_lows, fall_highs)))
  84:
#Fill in this function for part 1.a:
def upsample(U,x):
    upsampled = np.zeros(x.size * U, dtype=x.dtype)
    upsampled[::U] = x
    return upsampled

#Fill in this function for part 1.c:
def lowpass(C):
    filter_bands = [0,C/np.pi-0.05,C/np.pi+0.05,1]
    filter_desired = [1,0]
    filter_remez = signal.remez(50,filter_bands,filter_desired,fs=2)
    return filter_remez

#Test code for part 1.a:
test_signal = np.array([1,2,3,4,5,6])
print("original:", test_signal)
print("upsampled:", upsample(3, test_signal))

#Code for part 1.b:
plt.figure(figsize=(20,10))

toy_og = toy_signal(np.pi / 2)
X_og = np.fft.fftshift(np.fft.fft(toy_og))
w = np.linspace(-np.pi,np.pi,len(X_og))
plt.subplot(131)
plt.title('Original Toy Signal FFT Magnitude')
plt.plot(w, abs(X_og))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

toy_us = upsample(3, toy_og)
X_us = np.fft.fftshift(np.fft.fft(toy_us))
w = np.linspace(-np.pi,np.pi,len(X_us))
plt.subplot(132)
plt.title('Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_us))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')

#Code for part 1.c:
lpf_3 = lowpass(np.pi / 3)
toy_f = signal.convolve(toy_us, lpf_3)
X_f = np.fft.fftshift(np.fft.fft(toy_f))
w = np.linspace(-np.pi,np.pi,len(X_f))
plt.subplot(133)
plt.title('Filtered Upsampled Toy Signal FFT Magnitude')
plt.plot(w, abs(X_f))
plt.xlabel('$\omega$')
plt.ylabel('Magnitude')
  85:
#Fill in this function for part 2.a:
def downsample(D,x):
    
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])

#Code for part 2.b:


#Code for part 2.c:


#Code for part 2.d:

%history -g
  86:
#Fill in this function for part 2.a:
def downsample(D,x):
    
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])

#Code for part 2.b:


#Code for part 2.c:


#Code for part 2.d:

%history -g -f Lab7.ipynb
  87:
#Fill in this function for part 2.a:
def downsample(D,x):
    
    return downsampled

#Test code for part 2.a:
test_signal = np.array([1,2,3,4,5,6])

#Code for part 2.b:


#Code for part 2.c:


#Code for part 2.d:

%history -g
  88: %history -g -f temp
